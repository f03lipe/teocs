#!/usr/bin/env python3

# Compiler I: Syntax Analysis
# I'M READY FOR CODING!

from functools import reduce
from urllib.parse import quote
import sys
import os

from jacktokenizer import JackTokenizer
from vmwriter import VMWriter
from symboltable import SymbolTable

KEYWORDS = ('class', 'constructor', 'function', 'method', 'field',
            'static', 'var', 'int', 'char', 'boolean', 'void', 'true', 'false',
            'null', 'this', 'let', 'do', 'if', 'else', 'while', 'return')
SYMBOLS = ('{', '}', '(', ')', '[', ']', '.', ',', ';', '+',
            '-', '*', '/', '&', '|', '<', '>', '=',  '~')

KEYWORD = 0
SYMBOL = 1
IDENTIFIER = 2
INT_CONST = 3
STRING_CONST = 4

TYPES = {
    KEYWORD: "keyword",
	SYMBOL: "symbol",
	IDENTIFIER: "identifier",
	INT_CONST: "integerConstant",
	STRING_CONST: "stringConstant",
}

class CompilationEngine(object):
    """ Effects the actual compilation output. Gets its input from a
    JackTokenizer and emits its parsed structure into an output file/stream. The
    output is generated by a series of compilexxx() routines, one for every
    syntactic element xxx of the Jack grammar. The contract between these
    routines is that each compilexxx() routine should read the syntactic
    construct xxx from the input, advance() the tokenizer exactly beyond xxx,
    and output the parsing of xxx. Thus, compilexxx() may only be called if
    indeed xxx is the next syntactic element of the input. In the first version
    of the compiler, described in Chapter 10, this module emits a structured
    printout of the code, wrapped in XML tags. In the final version of the
    compiler, described in Chapter 11, this module generates executable VM code.
    In both cases, the parsing logic and module API are exactly the same.
    """

    _get_token = lambda self: self.tknz.current_token
    _get_ttype = lambda self: self.tknz.token_type
    _get_nttype = lambda self: TYPES[self._get_ttype()]

    markTag = lambda self, xxx: self._print("<%s>" % xxx)
    unmarkTag = lambda self, xxx: self._print("</%s>" % xxx)
    _makeToken = staticmethod(lambda tag, content:
                "<{tag}> {content} </{tag}>".format(tag=tag, content=content))
 
    def printToken(self):
        self._print(self._makeToken(TYPES[self._get_ttype()],
                 self._get_token()))
    
    def _process_token(self, bool_expression):
        """ processa um token, imprime o token e avan√ßa """
        assert bool_expression, 'error here: %s' % self._get_token()
        self.printToken()
        self.tokenizer.advance()
    
    def __init__(self, tokenizer, vmwriter, symboltable):
        """ does all that crap """ 
        self.tknz = tokenizer
        self.vmw = vmwriter
        self.st = symboltable
    
    def run(self):
        """ starts the process """ 
        self.tknz.advance()
        self.compileClass()
        self.vmw.close()
    
    def _pass_ttype(self, *ttype_options):
        """ processes a token based on its type.
        returns token.
        """
        saved = self._get_token()
        assert self._get_ttype() in ttype_options, \
            "unexpected ttype, %s should be in %s" % (TYPES[self._get_ttype()],
            [TYPES[e] for e in ttype_options])
        self.tknz.advance()
        return saved

    def _pass_token(self, *token_options):
        """ processes a token based on its format.
        returns token.
        """
        saved = self._get_token()
        assert self._get_token() in token_options, \
              "unexpected token, %s should be in %s" % (self._get_token(),
              token_options)
        self.tknz.advance()
        return saved

    def compileClass(self):
        """ Compiles a class. """

        self._pass_token("class")
        self.class_name = self._pass_ttype(IDENTIFIER)
        self._pass_token("{")

        token = self._get_token()
        while token != '}':
            if token in ('field', 'static'):
                self.compileClassVarDec()
            elif token in ('constructor', 'method', 'function'):
                self.compileSubroutine()
            else:
                raise Exception("wtf?", token)
            token = self._get_token()

        self._pass_token("}")
    
    def compileClassVarDec(self):
        """ compiles a static var declaration or a field var declaration. """
        
        var_kind = self._pass_token("static", "field")
        var_type = self._pass_ttype(KEYWORD, IDENTIFIER)
        var_name = self._pass_ttype(IDENTIFIER)

        self.st.scopes['class'].add(var_name, var_type, var_kind)

        self._pass_token(";")
    
    def compileSubroutine(self):
        """ compiles a subroutine """
        
        subroutine_type = self._pass_token("method", "constructor", "function")
        return_type = self._pass_ttype(KEYWORD, IDENTIFIER)
        subroutine_name = self._pass_ttype(IDENTIFIER)

        self.st.add_scope(subroutine_name)
        self.cur_subroutine = subroutine_name

        self._pass_token("(")
        self.compileParameterList()
        self._pass_token(")")

        locals_count = 0
        self._pass_token("{")
        while self._get_token() == 'var':
            locals_count += self.compileVarDec()

        self.vmw.writeFunction("%s.%s" % (self.class_name, subroutine_name),
                        locals_count)
        
        if self._get_token() in ('let','if','while','do','return'):
            self.compileStatements()
        self._pass_token("}")

    def compileParameterList(self):
        """ compiles a (possibly empty) parameter list """

        while self._get_token() != ")":
            varType = self._pass_ttype(KEYWORD, IDENTIFIER)
            varName = self._pass_ttype(IDENTIFIER)
            self.st.scopes[subroutine].add(varName, varType, 'argument')
            if self._get_token() == ',':
                self.tknz.advance()
        print(self.st.scopes[self.cur_subroutine].core)
    
    def compileVarDec(self):
        """ compiles a variable declaration. """

        self._pass_token("var")
        var_type = self._pass_ttype(KEYWORD, IDENTIFIER)
        var_name = self._pass_ttype(IDENTIFIER)
        vars_count = 1 
        while self._get_token() != ';':
            self.st.scopes[self.cur_subroutine].add(var_name, var_type, 'var')
            if self._get_token() == ',':
                self._pass_token(",")
                var_name = self._pass_ttype(IDENTIFIER)
                vars_count += 1
        self._pass_token(";")
        return vars_count
    
    def compileStatements(self):
        """ compiles a sequence of statements """

        while self._get_token() != '}':
            if self._get_token() == 'do':
                self.compileDo()
            elif self._get_token() == 'if':
                self.compileIf()
            elif self._get_token() == 'let':
                self.compileLet()
            elif self._get_token() == 'while':
                self.compileWhile()
            elif self._get_token() == 'return':
                self.compileReturn()
            else:
                raise Exception("wtf?", self._get_token())
    
    def compileDo(self):
        
        self._pass_token('do')
        
        a = self._pass_ttype(IDENTIFIER)
        if self._get_token() == ".":
            self._pass_token(".")
            # a is class name, b is subroutine
            b = self._pass_ttype(IDENTIFIER)
        else:
            # a is a subroutine from actual class
            b = a
            a = self.class_name

        args = 1
        self.vmw.write("push argument 0") # this
        self._pass_token("(")
        args += self.compileExpressionList()
        self._pass_token(")")
        self._pass_token(";")
        self.vmw.write("call %s.%s %s" % (a, b, args))
    
    def compileLet(self):
        """ compiles a let statement """
        
        self._pass_token("let")
        final_var = self._pass_ttype(IDENTIFIER)
        
        if self._get_token() == '[':
            self._pass_token("[")
            self.compileExpression()
            self._pass_token("]")

        self._pass_token("=")
        self.compileExpression()
        self._pass_Token(";")

    def cdompileLet(self):
        """ Compiles a let statement. """

        getToken = self._get_token
        getTType = self._get_ttype
        processToken = self._process_token
        
        self.markTag("letStatement")
        # 'let'
        processToken(getToken() == 'let')
        # varName
        processToken(getTType() == IDENTIFIER)
        if getToken() == '[':
            processToken(getToken() == '[')
            self.compileExpression()
            processToken(getToken() == ']')
        processToken(getToken() == '=')
        self.compileExpression()
        processToken(getToken() == ';')

        self.unmarkTag("letStatement")

    def compileWhile(self):
        """ Compiles a while statement. """
        
        getToken = self._get_token
        getTType = self._get_ttype
        processToken = self._process_token
        
        self.markTag("whileStatement")

        processToken(getToken() == 'while') # 'while'
        processToken(getToken() == '(') # '('
        self.compileExpression() # expression
        processToken(getToken() == ')') # ')'
        processToken(getToken() == '{') # '}'
        self.compileStatements() # statements List
        processToken(getToken() == '}') # '}'

        self.unmarkTag("whileStatement")

    def compileReturn(self):
        """ Compiles a return statement. """

        getToken = self._get_token
        getTType = self._get_ttype
        processToken = self._process_token

        self.markTag("returnStatement")
       
        processToken(getToken() == 'return')
        if getToken() != ';':
            self.compileExpression()
        processToken(getToken() == ';')
        
        self.unmarkTag("returnStatement")

    def compileIf(self):
        """ Compiles an if statement, possibly with a trailing else clause. """

        getToken = self._get_token
        getTType = self._get_ttype
        processToken = self._process_token
        
        self.markTag("ifStatement")
        
        processToken(getToken() == 'if')
        processToken(getToken() == '(')
        self.compileExpression()
        processToken(getToken() == ')')
        processToken(getToken() == '{')
        self.compileStatements()
        processToken(getToken() == '}')
        
        self.unmarkTag("ifStatement")

    def compileExpression(self):
        self.compileTerm()

    def compileExpressiond(self):
        """ Compiles an expression. """
        
        getToken = self._get_token
        getTType = self._get_ttype
        processToken = self._process_token
        
        self.markTag("expression")
        
        self.compileTerm()
        while getToken() in ('+', '-', '*', '/', '&', '|', '<', '>', '='):
            processToken(True)
            self.compileTerm()
        
        self.unmarkTag("expression")
    
    def compileTerm(self):
        
        token = self._get_token()
        ttype = self._get_ttype()
        print(token, TYPES[ttype])
        if ttype == INT_CONST:
            self.vmw.write("push constant %s" % token)

            
    def compileTermd(self):
        """  Compiles a term. This routine is faced with a slight difficulty
        when trying to decide between some of the alternative parsing rules.
        Specifically, if the current token is an identifier, the routine must
        distinguish between a variable, an array entry, and a subroutine call.
        A single look-ahead token, which may be one of ‚Äú[‚Äú, ‚Äú(‚Äú, or ‚Äú.‚Äù
        suffices to distinguish between the three possibilities. Any other
        token is not part of this term and should not be advanced over. """

        getToken = self._get_token
        getTType = self._get_ttype
        processToken = self._process_token
        
        self.markTag("term")
        
        if getTType() in (INT_CONST, STRING_CONST):
            processToken(True)
        elif getToken() in ('true', 'false', 'null', 'this'):
            processToken(True)
        elif getTType() == IDENTIFIER:
            processToken(True)
            if getToken() == '[':
                processToken(True)
                self.compileExpression()
                processToken(getToken() == ']')
            elif getToken() == '.':
                processToken(getToken() == '.')
                processToken(getTType() == IDENTIFIER)
            if getToken() == '(':
                processToken(getToken() == '(')
                self.compileExpressionList()
                processToken(getToken() == ')')
        elif getToken() == '(': # '(' expression ')'
            processToken(True)
            self.compileExpression()
            processToken(getToken() == ')')
        elif getToken() in ('-','~'): # unaryOp term
            processToken(True)
            self.compileTerm()
        else:
            raise Exception("erro: %s, %s" % (getToken(), TYPES[getTType()]))
        
        self.unmarkTag("term")
    
    def compileExpressionList(self):
        exps = 0
        while self._get_token() != ')':
            self.compileExpression()
            exps += 1
            if self._get_token() == ',':
                self._pass_token(',')
        return exps
    
__usage__ = "USAGE: do.py <dirname/filename>"

def work_many(path):
    valid = filter(lambda base: base.endswith('.jack'), os.listdir(path))
    for file in valid:
        work_file(os.path.join(path, file))

def work_file(file_path):
    print("#"*80+'\n'+"#"*80)
    print("now working file: %s" % file_path)
    base = open(file_path)
    output = open(os.path.splitext(file_path)[0]+'.vm', 'w')
    tokenizer = JackTokenizer(base)
    symboltable = SymbolTable()
    vmwriter = VMWriter(output=output)
    cp = CompilationEngine(tokenizer=tokenizer, vmwriter=vmwriter,
                        symboltable=symboltable)
    cp.run()

if __name__ == "__main__":
    if not len(sys.argv) == 2:
        print(__usage__)
        exit(1)
    entry = os.path.abspath(sys.argv[1])
    if os.path.isfile(entry):
        work_file(entry)
    elif os.path.isabs(entry):
        work_many(entry)
    else:
        print(__usage__)
        exit(1)
