#!/usr/bin/env python3

# Compiler II: Syntax Analysis
# I'M READY FOR CODING!
# (srsly hope it works this time :P)

from functools import reduce
from urllib.parse import quote
import sys
import os

from jacktokenizer import JackTokenizer
from vmwriter import VMWriter
from symboltable import SymbolTable

KEYWORDS = ('class', 'constructor', 'function', 'method', 'field',
            'static', 'var', 'int', 'char', 'boolean', 'void', 'true', 'false',
            'null', 'this', 'let', 'do', 'if', 'else', 'while', 'return')
SYMBOLS = ('{', '}', '(', ')', '[', ']', '.', ',', ';', '+',
            '-', '*', '/', '&', '|', '<', '>', '=',  '~')

KEYWORD = 0
SYMBOL = 1
IDENTIFIER = 2
INT_CONST = 3
STRING_CONST = 4

TYPES = {
    KEYWORD: "keyword",
	SYMBOL: "symbol",
	IDENTIFIER: "identifier",
	INT_CONST: "integerConstant",
	STRING_CONST: "stringConstant",
}

class CompilationEngine(object):
    """ Effects the actual compilation output. Gets its input from a
    JackTokenizer and emits its parsed structure into an output file/stream. The
    output is generated by a series of compilexxx() routines, one for every
    syntactic element xxx of the Jack grammar. The contract between these
    routines is that each compilexxx() routine should read the syntactic
    construct xxx from the input, advance() the tokenizer exactly beyond xxx,
    and output the parsing of xxx. Thus, compilexxx() may only be called if
    indeed xxx is the next syntactic element of the input. In the first version
    of the compiler, described in Chapter 10, this module emits a structured
    printout of the code, wrapped in XML tags. In the final version of the
    compiler, described in Chapter 11, this module generates executable VM code.
    In both cases, the parsing logic and module API are exactly the same.
    """
    _get_token = lambda self: self.tknz.current_token
    _get_ttype = lambda self: self.tknz.token_type
    _get_nttype = lambda self: TYPES[self._get_ttype()]
    
    def __init__(self, tokenizer, vmwriter, symboltable):
        """ whatever... """
        
        self.tknz = tokenizer
        self.vmw = vmwriter
        self.st = symboltable
        
        self.tknz.advance()
        self.compileClass()
        self.vmw.close()

__usage__ = "USAGE: newdo.py [dirname]|[filename]"

def work_dir(path):
	valid = filter(lambda base: base.endswith('.jack'), os.listdi(path))
	for file in valid:
		work_file(os.path.join(path, file))

def work_file(path):
	print("#"*80, "#"*80, "now working file: %s" % file_path, sep='\n')
	
def error():
	print(__usage__)
	exit(1)

if __name__ == '__main__':
	if not len(sys.argv) == 2: error()
	entry = os.path.abspath(sys.argv[1])
	if os.path.isfile(entry): # compile single file
		work_file(entry)
	elif os.path.isabs(entry): # compile full directory
		work_dir(entry)
	else: error()
	
	





















